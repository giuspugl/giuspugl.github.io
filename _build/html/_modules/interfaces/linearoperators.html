<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>interfaces.linearoperators &mdash; COSmic Microwave background linear Operators MAp-making Preconditioner 0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="COSmic Microwave background linear Operators MAp-making Preconditioner 0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../index.html">COSmic Microwave background linear Operators MAp-making Preconditioner 0 documentation</a></div>
        <div class="rel">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for interfaces.linearoperators</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">math</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">linop.linop</span> <span class="kn">as</span> <span class="nn">lp</span>
<span class="kn">import</span> <span class="nn">blkop</span> <span class="kn">as</span> <span class="nn">blk</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="kn">as</span> <span class="nn">rd</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">as</span> <span class="nn">spla</span>
<span class="kn">from</span> <span class="nn">utilities</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="FilterLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO">[docs]</a><span class="k">class</span> <span class="nc">FilterLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When applied to :math:`n_t` vector, this  operator filters out</span>
<span class="sd">    its components by removing a constant (its mean value) within a *subscan*</span>
<span class="sd">    interval.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``size``: {int}</span>
<span class="sd">        the size of the input array;</span>
<span class="sd">    - ``subscan_nsample``: {array}</span>
<span class="sd">        contains the size of each chunk of the samples which has to be processed.</span>
<span class="sd">        :math:`\sum_i subscan_{i} = size`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FilterLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="n">vec_out</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="mf">0.</span>
        <span class="n">offset</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">offset</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">:</span>
                <span class="n">start</span><span class="o">=</span><span class="n">offset</span>
                <span class="n">end</span><span class="o">=</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">offset</span><span class="o">+=</span><span class="n">i</span>
                <span class="n">vec_out</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span> <span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">vec_out</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">subscan_nsample</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">=</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="o">=</span><span class="n">subscan_nsample</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilterLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="SparseLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO">[docs]</a><span class="k">class</span> <span class="nc">SparseLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived class from the one from the  :class:`LinearOperator` in :mod:`linop`.</span>
<span class="sd">    It constitutes an interface for dealing with the projection operator</span>
<span class="sd">    (pointing matrix).</span>

<span class="sd">    Since this can be represented as a sparse matrix, it is initialized \</span>
<span class="sd">    by an array of observed pixels which resembles the  ``(i,j)`` positions \</span>
<span class="sd">    of the non-null elements of  the matrix,``obs_pixs``.</span>

<span class="sd">    .. note::</span>

<span class="sd">        During its initialization,  a private member function :func:`initializeweights` is called</span>
<span class="sd">        to precompute arrays needed for the explicit implementation of</span>
<span class="sd">        :class:`interfaces.BlockDiagonalPreconditionerLO`.</span>


<span class="sd">    **Parameters**</span>

<span class="sd">    - ``n`` : {int}</span>
<span class="sd">        number of columns;</span>
<span class="sd">    - ``m`` : {int}</span>
<span class="sd">        number of rows;</span>
<span class="sd">    - ``obs_pixs`` : {array}</span>
<span class="sd">         pixels index ``j`` of the non-null elements of :math:`A_{i,j}`;</span>
<span class="sd">    - ``pol`` : {int,[*default* `pol=1`]}</span>
<span class="sd">        process an intensity only (``pol=1``), polarization only ``pol=2``</span>
<span class="sd">         and intensity+polarization map (``pol=3``);</span>
<span class="sd">    - `phi`: {array, [*default* `None`]}</span>
<span class="sd">        array with polarization angles (if ``pol=3,2``).</span>
<span class="sd">    - ``w``: {array, [*default* `None`]}</span>
<span class="sd">        array with noise weights , :math:`w_t= N^{-1} _{tt}`, computed by</span>
<span class="sd">        :func:`BlockLO.build_blocks`.   If it is  not set :func:`SparseLO.initializeweights`</span>
<span class="sd">        assumes it to be a :func:`numpy.ones` array.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SparseLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product of a sparse matrix :math:`Av`,\</span>
<span class="sd">         with :math:`v` a  :mod:`numpy`  array (:math:`dim(v)=n_{pix}`)  .</span>

<span class="sd">        It extracts the components of :math:`v` corresponding  to the non-null \</span>
<span class="sd">        elements of the operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="SparseLO.rmult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.rmult">[docs]</a>    <span class="k">def</span> <span class="nf">rmult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product for the transpose operator :math:`A^T`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x</span></div>
<div class="viewcode-block" id="SparseLO.mult_qu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.mult_qu">[docs]</a>    <span class="k">def</span> <span class="nf">mult_qu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs :math:`A * v` with :math:`v` being a *polarization* vector.</span>
<span class="sd">        The output array will encode a linear combination of the two Stokes</span>
<span class="sd">        parameters,  (whose components are stored contiguously).</span>

<span class="sd">        .. math::</span>
<span class="sd">            d_t=  Q_p \cos(2\phi_t)+ U_p \sin(2\phi_t).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">pix</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">+=</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span>

        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="SparseLO.rmult_qu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.rmult_qu">[docs]</a>    <span class="k">def</span> <span class="nf">rmult_qu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs :math:`A^T * v`. The output vector will be a QU-map-like array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec_out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vec_in</span><span class="p">,</span><span class="n">pix</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
            <span class="n">vec_out</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">+=</span>   <span class="p">(</span><span class="n">vec_in</span><span class="o">*</span> <span class="n">cos</span><span class="p">)</span>
            <span class="n">vec_out</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span>   <span class="p">(</span><span class="n">vec_in</span><span class="o">*</span><span class="n">sin</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vec_out</span>

</div>
<div class="viewcode-block" id="SparseLO.mult_iqu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.mult_iqu">[docs]</a>    <span class="k">def</span> <span class="nf">mult_iqu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product of a sparse matrix :math:`Av`,\</span>
<span class="sd">        with ``v`` a  :mod:`numpy` array containing the</span>
<span class="sd">        three Stokes parameters [IQU] .</span>

<span class="sd">        .. note::</span>
<span class="sd">            Compared to the operation ``mult`` this routine returns a</span>
<span class="sd">            :math:`n_t`-size vector defined as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                d_t= I_p + Q_p \cos(2\phi_t)+ U_p \sin(2\phi_t).</span>

<span class="sd">            with :math:`p` is the pixel observed at time :math:`t` with polarization angle</span>
<span class="sd">            :math:`\phi_t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pix</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="SparseLO.rmult_iqu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.rmult_iqu">[docs]</a>    <span class="k">def</span> <span class="nf">rmult_iqu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product for the transpose operator :math:`A^T` to get a IQU map-like vector.</span>
<span class="sd">        Since this vector resembles the pixel of 3 maps it has 3 times the size ``Npix``.</span>
<span class="sd">        IQU values referring to the same pixel are  contiguously stored in the memory.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
        <span class="n">zipped_arrs</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vec_in</span><span class="p">,</span><span class="n">pix</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>    <span class="o">+=</span>    <span class="n">vec_in</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">+=</span>   <span class="p">(</span><span class="n">vec_in</span><span class="o">*</span><span class="n">cos</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">+=</span>   <span class="p">(</span><span class="n">vec_in</span><span class="o">*</span><span class="n">sin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="SparseLO.initializeweights"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.initializeweights">[docs]</a>    <span class="k">def</span> <span class="nf">initializeweights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-compute the quantitities needed in the explicit</span>
<span class="sd">        implementation of :math:`(A^T A)`:</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - ``counts`` :</span>
<span class="sd">            how many times a given pixel is observed in the timestream;</span>
<span class="sd">        - ``mask``:</span>
<span class="sd">          mask from  either unobserved pixels (``counts=0``)  or   bad constrained</span>
<span class="sd">          (see the ``pol=3,2`` following cases) ;</span>
<span class="sd">        - *If* ``pol=2``:</span>
<span class="sd">            the matrix :math:`(A^T A)`  is  symmetric and block-diagonal, each block</span>
<span class="sd">            can be written as :</span>

<span class="sd">            .. csv-table::</span>

<span class="sd">                &quot;:math:`\sum_t cos^2 2 \phi_t`&quot;, &quot;:math:`\sum_t sin 2\phi_t cos 2 \phi_t`&quot;</span>
<span class="sd">                &quot;:math:`\sum_t sin2 \phi_t cos 2 \phi_t`&quot;,   &quot;:math:`\sum_t sin^2 2 \phi_t`&quot;</span>

<span class="sd">            the determinant, the trace are therefore needed to compute the  eigenvalues</span>
<span class="sd">            of each block via the formula:</span>

<span class="sd">            .. math::</span>
<span class="sd">                \lambda_{min,max}= Tr(M)/2 \pm \sqrt{Tr^2(M)/4 - det(M)}</span>

<span class="sd">            being :math:`M` a ``2x2`` matrix.</span>
<span class="sd">            The eigenvalues are needed to define the mask of bad constrained pixels whose</span>
<span class="sd">            condition number is :math:`\gg 1`.</span>

<span class="sd">        - [*If*  ``pol=3``]:</span>
<span class="sd">            each block of the matrix :math:`(A^T A)`  is a ``3 x 3`` matrix:</span>

<span class="sd">            .. csv-table::</span>

<span class="sd">                &quot;:math:`n_{hits}`&quot;, &quot;:math:`\sum_t cos 2 \phi_t`&quot;, &quot;:math:`\sum_t sin 2 \phi_t`&quot;</span>
<span class="sd">                &quot;:math:`\sum_t cos 2 \phi_t`&quot;, &quot;:math:`\sum_t cos^2 2 \phi_t`&quot;, &quot;:math:`\sum_t sin 2\phi_t cos 2 \phi_t`&quot;</span>
<span class="sd">                &quot;:math:`\sum_t sin 2 \phi_t`&quot;,  &quot;:math:`\sum_t sin2 \phi_t cos 2 \phi_t`&quot;,   &quot;:math:`\sum_t sin^2 2 \phi_t`&quot;</span>

<span class="sd">            We then define the mask of bad constrained pixels by both  considering</span>
<span class="sd">            the condition number similarly as in the ``pol=2`` case and the pixels</span>
<span class="sd">            whose count is :math:`\geq 3`.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">weight</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">cos</span><span class="o">*</span><span class="n">cos</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">sin</span><span class="o">*</span><span class="n">sin</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">cos</span><span class="o">*</span><span class="n">sin</span>
            <span class="n">det</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">)</span>
            <span class="n">tr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span>
            <span class="n">sqrt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tr</span><span class="o">*</span><span class="n">tr</span><span class="o">/</span><span class="mf">4.</span> <span class="o">-</span><span class="n">det</span><span class="p">)</span>
            <span class="n">lambda_max</span><span class="o">=</span><span class="n">tr</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">sqrt</span>
            <span class="n">lambda_min</span><span class="o">=</span><span class="n">tr</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">sqrt</span>
            <span class="n">cond_num</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_max</span><span class="o">/</span><span class="n">lambda_min</span><span class="p">)</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond_num</span><span class="o">&lt;=</span><span class="mf">1.e3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c">#self.cos2[mask]/=det[mask]</span>
            <span class="c">#self.sin2[mask]/=det[mask]</span>
            <span class="c">#self.sincos[mask]/=det[mask]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="o">=</span><span class="n">det</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cosine</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sine</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">weight</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cosine</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">cos</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sine</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">sin</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">cos</span><span class="o">*</span><span class="n">cos</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">sin</span><span class="o">*</span><span class="n">sin</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">[</span><span class="n">pix</span><span class="p">]</span><span class="o">+=</span><span class="n">weight</span><span class="o">*</span><span class="n">sin</span><span class="o">*</span><span class="n">cos</span>

            <span class="n">det_block</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">)</span>
            <span class="n">Tr_block</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span>
            <span class="n">sqrt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tr_block</span><span class="o">*</span><span class="n">Tr_block</span><span class="o">/</span><span class="mf">4.</span> <span class="o">-</span><span class="n">det_block</span><span class="p">)</span>
            <span class="n">lambda_max</span><span class="o">=</span><span class="n">Tr_block</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">sqrt</span>
            <span class="n">lambda_min</span><span class="o">=</span><span class="n">Tr_block</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">sqrt</span>
            <span class="n">cond_num</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_max</span><span class="o">/</span><span class="n">lambda_min</span><span class="p">)</span>
            <span class="n">mask1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond_num</span><span class="o">&lt;=</span><span class="mf">1.e2</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>


</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">obs_pixs</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">pol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">=</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">=</span><span class="n">pol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="o">=</span><span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="o">=</span><span class="n">obs_pixs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializeweights</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span><span class="o">=</span><span class="s">&#39;IQU&#39;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SparseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">pol</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult_iqu</span><span class="p">,</span>
                                            <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult_iqu</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span><span class="o">=</span><span class="s">&#39;I&#39;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SparseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">n</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span><span class="o">=</span><span class="s">&#39;QU&#39;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SparseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">pol</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult_qu</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult_qu</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;No valid polarization key set!</span><span class="se">\t</span><span class="s">=&gt;</span><span class="se">\t</span><span class="s">pol=</span><span class="si">%d</span><span class="s"> </span><span class="se">\n</span><span class="s"> </span><span class="se">\</span>
<span class="s">                                    Possible values are pol=</span><span class="si">%d</span><span class="s">(I),</span><span class="si">%d</span><span class="s">(QU), </span><span class="si">%d</span><span class="s">(IQU).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SparseLO.maptype"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.maptype">[docs]</a>    <span class="k">def</span> <span class="nf">maptype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string depending on the map you are processing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span>

</div></div>
<div class="viewcode-block" id="ToeplitzLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.ToeplitzLO">[docs]</a><span class="k">class</span> <span class="nc">ToeplitzLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived Class from a LinearOperator. It exploit the symmetries of an ``dim x dim``</span>
<span class="sd">    Toeplitz matrix.</span>
<span class="sd">    This particular kind of matrices satisfy the following relation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        A_{i,j}=A_{i+1,j+1}=a_{i-j}</span>

<span class="sd">    Therefore, it is enough to initialize ``A`` by mean of an array ``a`` of ``size = dim``.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``a`` : {array, list}</span>
<span class="sd">        the array which resembles all the elements of the Toeplitz matrix;</span>
<span class="sd">    - ``size`` : {int}</span>
<span class="sd">        size of the block.</span>

<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="ToeplitzLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.ToeplitzLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product of a Toeplitz matrix with a vector ``x``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">val</span><span class="o">*</span><span class="n">v</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
            <span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">val</span><span class="o">*</span><span class="n">v</span>
            <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">+=</span><span class="n">temp</span><span class="p">[:</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ToeplitzLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">=</span><span class="n">a</span>
</div>
<div class="viewcode-block" id="BlockLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO">[docs]</a><span class="k">class</span> <span class="nc">BlockLO</span><span class="p">(</span><span class="n">blk</span><span class="o">.</span><span class="n">BlockDiagonalLinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived class from  :mod:`blkop.BlockDiagonalLinearOperator`.</span>
<span class="sd">    It basically relies on the definition of a block diagonal operator,</span>
<span class="sd">    composed by ``nblocks`` diagonal operators.</span>
<span class="sd">    If it does not have any  off-diagonal terms (*default case* ), each block is a multiple  of</span>
<span class="sd">    the identity characterized by the  values listed in ``t`` and therefore is</span>
<span class="sd">    initialized by the :func:`BlockLO.build_blocks` as a :class:`linop.DiagonalOperator`.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``blocksize`` : {int}</span>
<span class="sd">        size of each diagonal block, it is : :math:`blocksize= n/nblocks`.</span>
<span class="sd">    - ``t`` : {array}</span>
<span class="sd">        noise values for each block</span>
<span class="sd">    - ``offdiag`` : {bool, default ``False``}</span>
<span class="sd">        strictly  related to the way  the array ``t`` is passed (see notes ).</span>

<span class="sd">        .. note::</span>

<span class="sd">            - True : ``t`` is a list of array,</span>
<span class="sd">                    ``shape(t)= [nblocks,bandsize]``, to have a Toeplitz band diagonal operator,</span>
<span class="sd">                    :math:`bandsize != blocksize`</span>
<span class="sd">            - False : ``t`` is an array, ``shape(t)=[nblocks]``.</span>
<span class="sd">                    each block is identified by a scalar value in the diagonal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BlockLO.build_blocks"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO.build_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">build_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build each block of the operator either with or</span>
<span class="sd">        without off diagonal terms.</span>
<span class="sd">        Each block is initialized as a Toeplitz (either **band** or **diagonal**)</span>
<span class="sd">        linear operator.</span>

<span class="sd">        .. see also::</span>

<span class="sd">        ``self.diag``: {numpy array}</span>
<span class="sd">            the array resuming the :math:`diag(N^{-1})`.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isoffdiag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">ToeplitzLO</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isoffdiag</span><span class="p">:</span>
            <span class="n">tmplist</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">DiagonalOperator</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

                <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmplist</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">blocksize</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">offdiag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isoffdiag</span> <span class="o">=</span> <span class="n">offdiag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="o">=</span><span class="n">blocksize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="o">=</span><span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_blocks</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BlockLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="BlockLO.isoffdiag"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO.isoffdiag">[docs]</a>    <span class="k">def</span> <span class="nf">isoffdiag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property saying whether or not the operator has</span>
<span class="sd">        off-diagonal terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isoffdiag</span>

</div></div>
<div class="viewcode-block" id="BlockDiagonalLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalLO">[docs]</a><span class="k">class</span> <span class="nc">BlockDiagonalLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicit implementation of :math:`A \, diag(N^{-1}) A^T`, in order to save time</span>
<span class="sd">    in the application of the two matrices onto a vector (in this way the leading dimension  will be :math:`n_{pix}`</span>
<span class="sd">    instead of  :math:`n_t`).</span>

<span class="sd">    .. note::</span>
<span class="sd">        it is initialized as the  :class:`BlockDiagonalPreconditionerLO` since it involves</span>
<span class="sd">        computation with  the same matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">pol</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="n">pol</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">=</span><span class="n">pol</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BlockDiagonalLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>\
                                                <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sin2</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sincos</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">cos2</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">cosine</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sine</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>

<div class="viewcode-block" id="BlockDiagonalLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplication of  :math:`A \, diag(N^{-1}) A^T` on to a vector math:`x`</span>
<span class="sd">        ( :math:`n_{pix}` array).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mf">0.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">hits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">,</span>\
                                                <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">):</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">=</span> <span class="n">hits</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>  <span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>  <span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span>  <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">):</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="n">c2</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>  <span class="n">cs</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">y</span>




</div></div>
<div class="viewcode-block" id="BlockDiagonalPreconditionerLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalPreconditionerLO">[docs]</a><span class="k">class</span> <span class="nc">BlockDiagonalPreconditionerLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standard preconditioner defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        M_{BD}=( A \, diag(N^{-1}) A^T)^{-1}</span>

<span class="sd">    where :math:`A` is a :class:`SparseLO` operator.</span>
<span class="sd">    Such inverse operator  could be easily computed given the structure of the</span>
<span class="sd">    matrix :math:`A`. It could be  sparse in the case of Intensity only analysis (`pol=1`),</span>
<span class="sd">    block-sparse if polarization is included (`pol=3,2`).</span>


<span class="sd">    **Parameters**</span>

<span class="sd">    - ``n``:{int}</span>
<span class="sd">        the size of the problem, ``npix``;</span>
<span class="sd">    - ``A``:{:class:SparseLO}</span>
<span class="sd">        the linear operator related to the pointing matrix. Its members (`counts`, `masks`,</span>
<span class="sd">        `sine`, `cosine`, etc... ) are  needed to explicitly compute the inverse of the</span>
<span class="sd">        :math:`n_{pix}` blocks of :math:`M_{BD}`.</span>
<span class="sd">    - ``pol``:{int}</span>
<span class="sd">        the size of each block of the matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BlockDiagonalPreconditionerLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalPreconditionerLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Action of :math:`y=( A \, diag(N^{-1}) A^T)^{-1} x`,</span>
<span class="sd">        where :math:`x` is   an :math:`n_{pix}` array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mf">0.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">determ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">)</span>\
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span>\
                <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span>

            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">det</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">hits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="n">determ</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">,</span>\
                                <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">):</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">=</span><span class="p">((</span><span class="n">c2</span><span class="o">*</span><span class="n">s2</span><span class="o">-</span><span class="n">cs</span><span class="o">*</span><span class="n">cs</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">cs</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span><span class="p">(</span> <span class="n">c</span><span class="o">*</span><span class="n">cs</span><span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">s</span><span class="o">*</span><span class="n">cs</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span> <span class="p">(</span><span class="n">hits</span><span class="o">*</span><span class="n">s2</span><span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span><span class="p">(</span> <span class="n">s</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">hits</span><span class="o">*</span><span class="n">cs</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">c</span><span class="o">*</span><span class="n">cs</span> <span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="n">hits</span><span class="o">*</span><span class="n">cs</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span><span class="p">(</span><span class="n">hits</span><span class="o">*</span><span class="n">c2</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span><span class="p">,</span><span class="n">determ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">):</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="p">(</span><span class="n">s2</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">-</span> <span class="n">cs</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">determ</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>  <span class="p">(</span><span class="o">-</span><span class="n">cs</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">determ</span>

        <span class="k">return</span> <span class="n">y</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">pol</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="n">pol</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">=</span><span class="n">pol</span>
        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">det</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sin2</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">cos2</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sincos</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sin2</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">cos2</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sincos</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">cosine</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">sine</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BlockDiagonalPreconditionerLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>\
                                                            <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="InverseLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO">[docs]</a><span class="k">class</span> <span class="nc">InverseLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the inverse operator of a matrix :math:`A`, as a linear operator.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``A`` : {linear operator}</span>
<span class="sd">        the linear operator of the linear system to invert;</span>
<span class="sd">    - ``method`` : {function }</span>
<span class="sd">        the method to compute ``A^-1`` (see below);</span>
<span class="sd">    - ``P`` : {linear operator } (optional)</span>
<span class="sd">        the preconditioner for the computation of the inverse operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InverseLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It returns  :math:`y=A^{-1}x` by solving the linear system :math:`Ay=x`</span>
<span class="sd">        with a certain :mod:`scipy` routine (e.g. :func:`scipy.sparse.linalg.cg`)</span>
<span class="sd">        defined above as ``method``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span><span class="p">,</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preconditioner</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isconverged</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>
</div>
<div class="viewcode-block" id="InverseLO.isconverged"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.isconverged">[docs]</a>    <span class="k">def</span> <span class="nf">isconverged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It returns a Boolean value  depending on the</span>
<span class="sd">        exit status of the solver.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - ``info`` : {int}</span>
<span class="sd">            output of the solver method (usually :func:`scipy.sparse.cg`).</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__converged</span><span class="o">=</span><span class="n">info</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">preconditioner</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InverseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nargout</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="o">=</span><span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__preconditioner</span><span class="o">=</span><span class="n">preconditioner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__converged</span><span class="o">=</span><span class="bp">None</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="InverseLO.method"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.method">[docs]</a>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method to compute the inverse of A. \</span>
<span class="sd">        It can be any :mod:`scipy.sparse.linalg` solver, namely :func:`scipy.sparse.linalg.cg`,</span>
<span class="sd">        :func:`scipy.sparse.linalg.bicg`, etc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="InverseLO.converged"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.converged">[docs]</a>    <span class="k">def</span> <span class="nf">converged</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        provides convergence information:</span>

<span class="sd">        - 0 : successful exit;</span>
<span class="sd">        - &gt;0 : convergence to tolerance not achieved, number of iterations;</span>
<span class="sd">        - &lt;0 : illegal input or breakdown.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__converged</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="InverseLO.preconditioner"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.preconditioner">[docs]</a>    <span class="k">def</span> <span class="nf">preconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preconditioner for the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__preconditioner</span>

</div></div>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span><span class="n">lu</span>

<div class="viewcode-block" id="CoarseLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO">[docs]</a><span class="k">class</span> <span class="nc">CoarseLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains all the operation involving the coarse operator :math:`E`.</span>
<span class="sd">    In this implementation :math:`E` is always applied to a vector wiht</span>
<span class="sd">    its inverse : :math:`E^{-1}`.</span>
<span class="sd">    When initialized it performs an LU decomposition to accelerate the performances</span>
<span class="sd">    of the inversion.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``Z`` : {np.matrix}</span>
<span class="sd">            deflation matrix;</span>
<span class="sd">    - ``A`` : {SparseLO}</span>
<span class="sd">            to  compute vectors :math:`AZ_i`;</span>
<span class="sd">    - ``r`` :  {int}</span>
<span class="sd">            :math:`rank(Z)`, dimension of the deflation subspace.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CoarseLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the multiplication of the inverse coarse operator :math:`x=E^{-1} v`.</span>
<span class="sd">        It exploits the LU decomposition of :math:`E` to solve the system :math:`Ex=v`.</span>
<span class="sd">        It first solves :math:`y=L^{-1} v` and then :math:`x=U^{-1}y`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">lower</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">overwrite_b</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">overwrite_b</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="CoarseLO.set_operator"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO.set_operator">[docs]</a>    <span class="k">def</span> <span class="nf">set_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Az</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="n">M</span><span class="o">=</span><span class="n">dgemm</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">Az</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">=</span><span class="n">lu</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">permute_l</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">overwrite_a</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">check_finite</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Az</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operator</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">Az</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CoarseLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                            <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DeflationLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.DeflationLO">[docs]</a><span class="k">class</span> <span class="nc">DeflationLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class builds the Deflation operator (and its transpose)</span>
<span class="sd">    from the columns of the matrix ``Z``.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``z`` : {np.matrix}</span>
<span class="sd">            the deflation matrix. Its columns are read as arrays in a list ``self.z``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DeflationLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.DeflationLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the matrix vector multiplication   :math:`Z x`</span>
<span class="sd">        with  :math:`dim(x) = rank(Z)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">y</span><span class="o">+=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   <span class="c">#.astype(x.dtype)</span>
        <span class="k">return</span> <span class="n">y</span></div>
<div class="viewcode-block" id="DeflationLO.rmult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.DeflationLO.rmult">[docs]</a>    <span class="k">def</span> <span class="nf">rmult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product onto a ``N_pix`` vector with :math:`Z^T`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">scalprod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span> <span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">=</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[:,</span><span class="n">j</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DeflationLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span>
                                                <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Modules</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2015, Giuseppe Puglisi.
      Last updated on Feb 24, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>