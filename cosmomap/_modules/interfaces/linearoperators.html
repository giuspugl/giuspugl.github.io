<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>interfaces.linearoperators &mdash; COSMOMAP2 0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="COSMOMAP2 0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../index.html">COSMOMAP2</a></div>
        <div class="rel">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for interfaces.linearoperators</h1><div class="highlight"><pre>
<span class="c">#</span>
<span class="c">#   LINEAROPERATORS.PY</span>
<span class="c">#   collects several LinearOperator classes inheritating attributes from linop package</span>
<span class="c">#   date: 2016-12-02</span>
<span class="c">#   author: GIUSEPPE PUGLISI</span>
<span class="c">#</span>
<span class="c">#   Copyright (C) 2016   Giuseppe Puglisi    giuspugl@sissa.it</span>
<span class="c">#</span>



<span class="kn">import</span> <span class="nn">math</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">linop.linop</span> <span class="kn">as</span> <span class="nn">lp</span>
<span class="kn">import</span> <span class="nn">blkop</span> <span class="kn">as</span> <span class="nn">blk</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="kn">as</span> <span class="nn">rd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">weave</span>
<span class="kn">from</span> <span class="nn">scipy.weave</span> <span class="kn">import</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">as</span> <span class="nn">spla</span>
<span class="kn">from</span> <span class="nn">utilities</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">copy_reg</span> <span class="kn">import</span> <span class="n">pickle</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>


<div class="viewcode-block" id="GroundFilterLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.GroundFilterLO">[docs]</a><span class="k">class</span> <span class="nc">GroundFilterLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>

<div class="viewcode-block" id="GroundFilterLO.counts_in_groundbins"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.GroundFilterLO.counts_in_groundbins">[docs]</a>    <span class="k">def</span> <span class="nf">counts_in_groundbins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
        <span class="n">counts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">N</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">includes</span><span class="o">=</span><span class="s">r&quot;&quot;&quot;</span>
<span class="s">        #include &lt;stdio.h&gt;</span>
<span class="s">        #include &lt;omp.h&gt;</span>
<span class="s">        #include &lt;math.h&gt;</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">code</span> <span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        int i,groundbin;</span>
<span class="s">        for ( i=0;i&lt;N;++i){</span>
<span class="s">            groundbin=g(i);</span>
<span class="s">            if (groundbin == -1) continue;</span>
<span class="s">            counts(groundbin)+=1 ;</span>
<span class="s">            }</span>
<span class="s">            &quot;&quot;&quot;</span>
        <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;g&#39;</span><span class="p">,</span><span class="s">&#39;counts&#39;</span><span class="p">,</span><span class="s">&#39;N&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;-march=native  -O3  -fopenmp &#39;</span> <span class="p">],</span>
                <span class="n">support_code</span> <span class="o">=</span> <span class="n">includes</span><span class="p">,</span><span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts</span>
</div>
<div class="viewcode-block" id="GroundFilterLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.GroundFilterLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span>  <span class="o">-</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Pg</span> <span class="o">*</span><span class="n">v</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ground</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span>      <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ground</span> <span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts_in_groundbins</span><span class="p">(</span><span class="n">ground</span> <span class="p">)</span>
        <span class="n">G</span><span class="o">=</span><span class="n">SparseLO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="n">ground</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">counts</span>
        <span class="n">invGtG</span> <span class="o">=</span> <span class="n">BlockDiagonalPreconditionerLO</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Pg</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span> <span class="o">*</span><span class="n">invGtG</span> <span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GroundFilterLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_pickle_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">im_func</span><span class="o">.</span><span class="n">__name__</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">im_self</span>
    <span class="n">cls</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">im_class</span>
    <span class="k">return</span> <span class="n">_unpickle_method</span><span class="p">,</span> <span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unpickle_method</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>

<div class="viewcode-block" id="FilterLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO">[docs]</a><span class="k">class</span> <span class="nc">FilterLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When applied to :math:`n_t` vector, this  operator filters out</span>
<span class="sd">    *Legendre  Polynomial* components from it up to a certain order.</span>
<span class="sd">    In the simple case of a :math:`0-th` order polynomial the effect</span>
<span class="sd">     of filter consists of subtracting the offset from the samples.</span>


<span class="sd">    **Parameters**</span>

<span class="sd">    - ``size``: {int}</span>
<span class="sd">        the size of the input array;</span>
<span class="sd">    - ``subscan_nsample``: {list of 2 array}</span>
<span class="sd">        - ``subscan_nsample[0]``, contains the size of each chunk of the samples</span>
<span class="sd">            which has to be processed;</span>
<span class="sd">         - ``subscan_nsample[1]``, contains the starting sample index  of  each chunk;</span>

<span class="sd">    - ``samples_per_bolopair``:{list of int }</span>
<span class="sd">        Number of samples observed during one Constant Elevation Scan (CES) for</span>
<span class="sd">        any pair of detectors. If more CES are included it is a ``list of int``;</span>
<span class="sd">    - ``bolos_per_ces``:{list of int}</span>
<span class="sd">        Number of pairs of detectors that observed during a CES.</span>
<span class="sd">    - ``pix_samples``: {array}</span>
<span class="sd">        the same argument as in :class:`SparseLO`, encoding all the pixels observed</span>
<span class="sd">        during observations.</span>
<span class="sd">    - ``poly_order``: {int}</span>
<span class="sd">        maximum order of polynomials to be subtracted from the samples.</span>

<span class="sd">    .. note::</span>

<span class="sd">        To be consistent with tha analysis :class:`FilterLO` does not take into account</span>
<span class="sd">        all the flagged samples.</span>


<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FilterLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="n">vec_out</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="mf">0.</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels</span>
        <span class="n">offset</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">pixs</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">for</span> <span class="n">subsc</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">ns</span><span class="p">,</span><span class="n">nb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="p">):</span>
            <span class="n">n</span><span class="o">=</span><span class="n">nb</span><span class="o">*</span><span class="n">ns</span>
            <span class="n">bolo_iter</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">while</span> <span class="p">(</span> <span class="n">bolo_iter</span><span class="o">&lt;</span><span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subsc</span><span class="p">,</span><span class="n">ts</span><span class="p">):</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">bolo_iter</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
                    <span class="n">end</span><span class="o">=</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span>
                    <span class="n">code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">                	    int j;</span>
<span class="s">                        double mean=0.;</span>
<span class="s">                        double counter=0.;</span>
<span class="s">                        int tstart=start;</span>
<span class="s">                        int tend=end;</span>
<span class="s">                        for (j=tstart;j &lt; tend;++j){</span>
<span class="s">                            if (pixs(j) == -1){</span>
<span class="s">                                continue;</span>
<span class="s">                            }</span>
<span class="s">                            mean+= d(j);</span>
<span class="s">                            counter+=1.;</span>
<span class="s">                        }</span>
<span class="s">                        mean=mean/ counter;</span>
<span class="s">                        return_val=mean;</span>
<span class="s">                        &quot;&quot;&quot;</span>
                    <span class="n">dmean</span> <span class="o">=</span> <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;start&#39;</span><span class="p">,</span><span class="s">&#39;end&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39; -O3  -fopenmp&#39;</span> <span class="p">],</span>
                          <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">                    	               #include &lt;stdio.h&gt;</span>
<span class="s">                    	               #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
                          <span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">dmean</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dmean</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">vec_out</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span> <span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">dmean</span>
                <span class="n">bolo_iter</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">offset</span><span class="o">+=</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">vec_out</span>
</div>
<div class="viewcode-block" id="FilterLO.polyfilter"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO.polyfilter">[docs]</a>    <span class="k">def</span> <span class="nf">polyfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="n">vec_out</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="mf">0.</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels</span>
        <span class="n">offset</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">pixs</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">for</span> <span class="n">subsc</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">ns</span><span class="p">,</span><span class="n">nb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="p">):</span>
            <span class="n">n</span><span class="o">=</span><span class="n">nb</span><span class="o">*</span><span class="n">ns</span>
            <span class="n">bolo_iter</span><span class="o">=</span><span class="mi">0</span>

            <span class="k">while</span> <span class="p">(</span> <span class="n">bolo_iter</span><span class="o">&lt;</span><span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subsc</span><span class="p">,</span><span class="n">ts</span><span class="p">):</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">bolo_iter</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
                    <span class="n">end</span><span class="o">=</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span>
                    <span class="n">tmpmask</span><span class="o">=</span><span class="n">mask</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                    <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tmpmask</span><span class="o">==</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">size</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="p">:</span>
                        <span class="c">#too few samples to filter Legendre Polynomials</span>
                        <span class="k">continue</span>

                    <span class="n">legendres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legendres</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">i</span> <span class="p">:</span>
                        <span class="c">#orthonormalize the basis in the unflagged</span>
                        <span class="c"># samples by a  QR decomposition</span>
                        <span class="n">q</span><span class="p">,</span><span class="n">r</span>   <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">legendres</span><span class="p">[</span><span class="n">tmpmask</span><span class="p">])</span>
                        <span class="n">legendres</span><span class="o">=</span><span class="n">q</span>

                    <span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c">#normalize Polynomial basis</span>
                        <span class="n">filterbasis</span><span class="o">=</span><span class="n">legendres</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">p</span><span class="o">+=</span><span class="n">scalprod</span><span class="p">(</span><span class="n">filterbasis</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">tmpmask</span><span class="p">])</span><span class="o">*</span><span class="n">filterbasis</span>
                    <span class="n">vec_out</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">tmpmask</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">tmpmask</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span>
                <span class="n">bolo_iter</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">offset</span><span class="o">+=</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">vec_out</span>
</div>
<div class="viewcode-block" id="FilterLO.compute_legendres"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO.compute_legendres">[docs]</a>    <span class="k">def</span> <span class="nf">compute_legendres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">subscan_sizes</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">array</span>  <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span> <span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">subscan_sizes</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">subscan_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span> <span class="k">continue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legendres</span><span class="o">=</span><span class="p">{</span><span class="n">size</span><span class="p">:</span> <span class="n">get_legendre_polynomials</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="p">,</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">subscan_sizes</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="FilterLO.procsfilter"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO.procsfilter">[docs]</a>    <span class="k">def</span> <span class="nf">procsfilter</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span><span class="n">args</span><span class="p">):</span>
		<span class="n">d</span><span class="p">,</span><span class="n">subsc</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span><span class="n">ns</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span> <span class="n">args</span>
		<span class="n">vec_out</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="mf">0.</span>
		<span class="k">for</span> <span class="n">bolo_iter</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subsc</span><span class="p">,</span><span class="n">ts</span><span class="p">):</span>
				<span class="n">start</span><span class="o">=</span><span class="n">j</span> <span class="o">+</span><span class="n">ns</span><span class="o">*</span><span class="n">bolo_iter</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span><span class="n">i</span>
				<span class="n">tmpmask</span><span class="o">=</span><span class="n">mask</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
				<span class="n">size</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tmpmask</span><span class="o">==</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="n">legendres</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legendres</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
				<span class="k">if</span> 	 <span class="n">size</span> <span class="o">!=</span> <span class="n">i</span> <span class="p">:</span>
					<span class="n">q</span><span class="p">,</span><span class="n">r</span>   <span class="o">=</span>   <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">legendres</span><span class="p">[</span><span class="n">tmpmask</span><span class="p">])</span>
					<span class="n">legendres</span><span class="o">=</span><span class="n">q</span>

					<span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

						<span class="n">filterbasis</span><span class="o">=</span><span class="n">legendres</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span>
						<span class="n">p</span><span class="o">+=</span><span class="n">scalprod</span><span class="p">(</span><span class="n">filterbasis</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">tmpmask</span><span class="p">])</span><span class="o">*</span><span class="n">filterbasis</span>
						<span class="n">vec_out</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">tmpmask</span><span class="p">]</span><span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">tmpmask</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span>
				<span class="k">else</span> <span class="p">:</span>
					<span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
						<span class="n">filterbasis</span><span class="o">=</span><span class="n">legendres</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span>
						<span class="n">p</span><span class="o">+=</span><span class="n">scalprod</span><span class="p">(</span><span class="n">filterbasis</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span><span class="o">*</span><span class="n">filterbasis</span>
						<span class="n">vec_out</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span>

		<span class="k">return</span> <span class="n">vec_out</span>

</div>
<div class="viewcode-block" id="FilterLO.polyfilter_multithreads"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.FilterLO.polyfilter_multithreads">[docs]</a>    <span class="k">def</span> <span class="nf">polyfilter_multithreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
		<span class="n">vec_out</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="mf">0.</span>
		<span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels</span>
		<span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ns</span><span class="p">,</span><span class="n">nb</span><span class="p">:</span> <span class="n">ns</span><span class="o">*</span><span class="n">nb</span>
		<span class="n">offsend</span><span class="o">=</span><span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="p">)</span>
		<span class="n">offstart</span><span class="o">=</span><span class="n">offsend</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">offstart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">offsend</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">offsend</span><span class="p">)</span>
		<span class="n">offstart</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">offstart</span><span class="p">)</span>
		<span class="n">dces</span><span class="o">=</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offstart</span><span class="p">,</span><span class="n">offsend</span><span class="p">)]</span>
		<span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">pixs</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span>
		<span class="n">maskces</span><span class="o">=</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offstart</span><span class="p">,</span><span class="n">offsend</span><span class="p">)]</span>
		<span class="n">procs</span><span class="o">=</span><span class="n">Pool</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dces</span><span class="p">))</span>
		<span class="n">vec</span><span class="o">=</span>  <span class="n">procs</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">procsfilter</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="p">,</span><span class="n">maskces</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>


</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">subscan_nsample</span><span class="p">,</span><span class="n">samples_per_bolopair</span><span class="p">,</span><span class="n">bolos_per_ces</span><span class="p">,</span> <span class="n">pix_samples</span><span class="p">,</span><span class="n">poly_order</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">=</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="o">=</span><span class="n">samples_per_bolopair</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="o">=</span><span class="n">bolos_per_ces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="o">=</span><span class="n">subscan_nsample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="o">=</span><span class="n">subscan_nsample</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nbolos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subscans</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="o">=</span><span class="n">pix_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_order</span><span class="o">=</span><span class="n">poly_order</span>
        <span class="k">if</span> <span class="n">poly_order</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                    <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">poly_order</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_legendres</span><span class="p">()</span>
            <span class="n">pickle</span><span class="p">(</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">_pickle_method</span><span class="p">,</span> <span class="n">_unpickle_method</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polyfilter_multithreads</span><span class="p">,</span>
                                                    <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="SparseLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO">[docs]</a><span class="k">class</span> <span class="nc">SparseLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived class from the one from the  :class:`LinearOperator` in :mod:`linop`.</span>
<span class="sd">    It constitutes an interface for dealing with the projection operator</span>
<span class="sd">    (pointing matrix).</span>

<span class="sd">    Since this can be represented as a sparse matrix, it is initialized \</span>
<span class="sd">    by an array of observed pixels which resembles the  ``(i,j)`` positions \</span>
<span class="sd">    of the non-null elements of  the matrix,``obs_pixs``.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``n`` : {int}</span>
<span class="sd">        size of the pixel domain ;</span>
<span class="sd">    - ``m`` : {int}</span>
<span class="sd">        size of  time domain;</span>
<span class="sd">        (or the non-null elements in a row of :math:`A_{i,j}`);</span>
<span class="sd">    - ``pix_samples`` : {array}</span>
<span class="sd">        list of pixels observed in the time domain,</span>
<span class="sd">        (or the non-null elements in a row of :math:`A_{i,j}`);</span>
<span class="sd">    - ``pol`` : {int,[*default* `pol=1`]}</span>
<span class="sd">        process an intensity only (``pol=1``), polarization only ``pol=2``</span>
<span class="sd">        and intensity+polarization map (``pol=3``);</span>
<span class="sd">    - ``angle_processed``: {:class:`ProcessTimeSamples`}</span>
<span class="sd">        the class (instantiated befor :class:`SparseLO`)has already computed</span>
<span class="sd">        the :math:`\cos 2\phi` and :math:`\sin 2\phi`, we link the ``cos`` and ``sin``</span>
<span class="sd">        attributes of this class to the  :class:`ProcessTimeSamples` ones ;</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SparseLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product of a sparse matrix :math:`Av`,\</span>
<span class="sd">         with :math:`v` a  :mod:`numpy`  array (:math:`dim(v)=n_{pix}`)  .</span>

<span class="sd">        It extracts the components of :math:`v` corresponding  to the non-null \</span>
<span class="sd">        elements of the operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="n">Nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	    int i;</span>

<span class="s">        for (i=0;i&lt;Nrows;++i){</span>
<span class="s">            if (pixs(i) == -1) continue;</span>
<span class="s">            x(i)+= v(pixs(i));</span>
<span class="s">            }</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;Nrows&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;  -O3  -fopenmp &#39;</span> <span class="p">],</span>
		            <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	                   #include &lt;stdio.h&gt;</span>
<span class="s">                       #include &lt;omp.h&gt;</span>
<span class="s">	                   #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
                       <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span></div>
<div class="viewcode-block" id="SparseLO.rmult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.rmult">[docs]</a>    <span class="k">def</span> <span class="nf">rmult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product for the transpose operator :math:`A^T`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
        <span class="n">Nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span>

        <span class="n">code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">           int i ;</span>
<span class="s">           for ( i=0;i&lt;Nrows;++i){</span>
<span class="s">            if (pixs(i) == -1) continue;</span>

<span class="s">            x(pixs(i))+=v(i);</span>
<span class="s">            }</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;Nrows&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;  -O3  -fopenmp &#39;</span> <span class="p">],</span>
		            <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	               #include &lt;stdio.h&gt;</span>
<span class="s">                   #include &lt;omp.h&gt;</span>
<span class="s">	               #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
                       <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span></div>
<div class="viewcode-block" id="SparseLO.mult_qu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.mult_qu">[docs]</a>    <span class="k">def</span> <span class="nf">mult_qu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs :math:`A * v` with :math:`v` being a *polarization* vector.</span>
<span class="sd">        The output array will encode a linear combination of the two Stokes</span>
<span class="sd">        parameters,  (whose components are stored contiguously).</span>

<span class="sd">        .. math::</span>
<span class="sd">            d_t=  Q_p \cos(2\phi_t)+ U_p \sin(2\phi_t).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="n">Nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span>
        <span class="n">cos</span><span class="p">,</span><span class="n">sin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">	       int i ;</span>
<span class="s">           for ( i=0;i&lt;Nrows;++i){</span>
<span class="s">            if (pixs(i) == -1) continue;</span>
<span class="s">            x(i)+=v(2*pixs(i)) *cos(i) + v(2*pixs(i)+1) *sin(i);</span>
<span class="s">            }</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;Nrows&#39;</span><span class="p">,</span><span class="s">&#39;cos&#39;</span><span class="p">,</span><span class="s">&#39;sin&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;  -O3  -fopenmp &#39;</span> <span class="p">],</span>
		      <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	               #include &lt;stdio.h&gt;</span>
<span class="s">                   #include &lt;omp.h&gt;</span>
<span class="s">	               #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
<div class="viewcode-block" id="SparseLO.rmult_qu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.rmult_qu">[docs]</a>    <span class="k">def</span> <span class="nf">rmult_qu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs :math:`A^T * v`. The output vector will be a QU-map-like array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec_out</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
        <span class="n">Nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span>
        <span class="n">cos</span><span class="p">,</span><span class="n">sin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">	       int i;</span>
<span class="s">           for ( i=0;i&lt;Nrows;++i){</span>
<span class="s">            if (pixs(i) == -1) continue;</span>
<span class="s">            vec_out(2*pixs(i)) += v(i)*cos(i);</span>
<span class="s">            vec_out(2*pixs(i)+1) += v(i)*sin(i);</span>
<span class="s">            }</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;vec_out&#39;</span><span class="p">,</span><span class="s">&#39;Nrows&#39;</span><span class="p">,</span><span class="s">&#39;cos&#39;</span><span class="p">,</span><span class="s">&#39;sin&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;  -O3  -fopenmp &#39;</span> <span class="p">],</span>
		      <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	               #include &lt;stdio.h&gt;</span>
<span class="s">                   #include &lt;omp.h&gt;</span>
<span class="s">	               #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vec_out</span></div>
<div class="viewcode-block" id="SparseLO.mult_iqu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.mult_iqu">[docs]</a>    <span class="k">def</span> <span class="nf">mult_iqu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product of a sparse matrix :math:`Av`,\</span>
<span class="sd">        with ``v`` a  :mod:`numpy` array containing the</span>
<span class="sd">        three Stokes parameters [IQU] .</span>

<span class="sd">        .. note::</span>
<span class="sd">            Compared to the operation ``mult`` this routine returns a</span>
<span class="sd">            :math:`n_t`-size vector defined as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                d_t= I_p + Q_p \cos(2\phi_t)+ U_p \sin(2\phi_t).</span>

<span class="sd">            with :math:`p` is the pixel observed at time :math:`t` with polarization angle</span>
<span class="sd">            :math:`\phi_t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="n">Nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span>
        <span class="n">cos</span><span class="p">,</span><span class="n">sin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	       int i ;</span>
<span class="s">           for ( i=0;i&lt;Nrows;++i){</span>
<span class="s">            if (pixs(i) == -1) continue;</span>
<span class="s">            x(i) +=  v(3*pixs(i)) + v(3*pixs(i)+1) *cos(i) + v(3*pixs(i)+2) *sin(i);</span>
<span class="s">            }</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;Nrows&#39;</span><span class="p">,</span><span class="s">&#39;cos&#39;</span><span class="p">,</span><span class="s">&#39;sin&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;  -O3  -fopenmp &#39;</span> <span class="p">],</span>
		      <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	               #include &lt;stdio.h&gt;</span>
<span class="s">                   #include &lt;omp.h&gt;</span>
<span class="s">	               #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
<div class="viewcode-block" id="SparseLO.rmult_iqu"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.rmult_iqu">[docs]</a>    <span class="k">def</span> <span class="nf">rmult_iqu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product for the transpose operator :math:`A^T` to get a IQU map-like vector.</span>
<span class="sd">        Since this vector resembles the pixel of 3 maps it has 3 times the size ``Npix``.</span>
<span class="sd">        IQU values referring to the same pixel are  contiguously stored in the memory.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
        <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">pixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs</span>
        <span class="n">cos</span><span class="p">,</span><span class="n">sin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">	       int i;</span>
<span class="s">           for ( i=0;i&lt;N;++i){</span>
<span class="s">            if (pixs(i) == -1) continue;</span>
<span class="s">            x(3*pixs(i))   += v(i);</span>
<span class="s">            x(3*pixs(i)+1) += v(i)*cos(i);</span>
<span class="s">            x(3*pixs(i)+2) += v(i)*sin(i);</span>
<span class="s">            }</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">inline</span><span class="p">(</span><span class="n">code</span><span class="p">,[</span><span class="s">&#39;pixs&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;N&#39;</span><span class="p">,</span><span class="s">&#39;cos&#39;</span><span class="p">,</span><span class="s">&#39;sin&#39;</span><span class="p">],</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		      <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39; -O3  -fopenmp &#39;</span> <span class="p">],</span>
		      <span class="n">support_code</span> <span class="o">=</span> <span class="s">r&quot;&quot;&quot;</span>
<span class="s">	               #include &lt;stdio.h&gt;</span>
<span class="s">                   #include &lt;omp.h&gt;</span>
<span class="s">	               #include &lt;math.h&gt;&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="n">libraries</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gomp&#39;</span><span class="p">],</span><span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span></div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">pix_samples</span><span class="p">,</span><span class="n">pol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">angle_processed</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">=</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="o">=</span><span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">=</span><span class="n">pol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="o">=</span><span class="n">pix_samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">angle_processed</span><span class="o">.</span><span class="n">cos</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">angle_processed</span><span class="o">.</span><span class="n">sin</span>

        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span><span class="o">=</span><span class="s">&#39;IQU&#39;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SparseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult_iqu</span><span class="p">,</span>
                                            <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult_iqu</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span><span class="o">=</span><span class="s">&#39;I&#39;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SparseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span><span class="o">=</span><span class="s">&#39;QU&#39;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SparseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult_qu</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult_qu</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;No valid polarization key set!</span><span class="se">\t</span><span class="s">=&gt;</span><span class="se">\t</span><span class="s">pol=</span><span class="si">%d</span><span class="s"> </span><span class="se">\n</span><span class="s"> </span><span class="se">\</span>
<span class="s">                                    Possible values are pol=</span><span class="si">%d</span><span class="s">(I),</span><span class="si">%d</span><span class="s">(QU), </span><span class="si">%d</span><span class="s">(IQU).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SparseLO.maptype"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.SparseLO.maptype">[docs]</a>    <span class="k">def</span> <span class="nf">maptype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string depending on the map you are processing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__runcase</span>

</div></div>
<div class="viewcode-block" id="ToeplitzLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.ToeplitzLO">[docs]</a><span class="k">class</span> <span class="nc">ToeplitzLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived Class from a LinearOperator. It exploit the symmetries of an ``dim x dim``</span>
<span class="sd">    Toeplitz matrix.</span>
<span class="sd">    This particular kind of matrices satisfy the following relation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        A_{i,j}=A_{i+1,j+1}=a_{i-j}</span>

<span class="sd">    Therefore, it is enough to initialize ``A`` by mean of an array ``a`` of ``size = dim``.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``a`` : {array, list}</span>
<span class="sd">        the array which resembles all the elements of the Toeplitz matrix;</span>
<span class="sd">    - ``size`` : {int}</span>
<span class="sd">        size of the block.</span>

<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="ToeplitzLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.ToeplitzLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product of a Toeplitz matrix with a vector ``x``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">val</span><span class="o">*</span><span class="n">v</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)):</span>
            <span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">val</span><span class="o">*</span><span class="n">v</span>
            <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">+=</span><span class="n">temp</span><span class="p">[:</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ToeplitzLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">=</span><span class="n">a</span>
</div>
<div class="viewcode-block" id="BlockLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO">[docs]</a><span class="k">class</span> <span class="nc">BlockLO</span><span class="p">(</span><span class="n">blk</span><span class="o">.</span><span class="n">BlockDiagonalLinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived class from  :mod:`blkop.BlockDiagonalLinearOperator`.</span>
<span class="sd">    It basically relies on the definition of a block diagonal operator,</span>
<span class="sd">    composed by ``nblocks`` diagonal operators.</span>
<span class="sd">    If it does not have any  off-diagonal terms (*default case* ), each block is a multiple  of</span>
<span class="sd">    the identity characterized by the  values listed in ``t`` and therefore is</span>
<span class="sd">    initialized by the :func:`BlockLO.build_blocks` as a :class:`linop.DiagonalOperator`.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``blocksize`` : {int or list }</span>
<span class="sd">        size of each diagonal block, if `int` it is : :math:`blocksize= n/nblocks`.</span>
<span class="sd">    - ``t`` : {array}</span>
<span class="sd">        noise values for each block</span>
<span class="sd">    - ``offdiag`` : {bool, default ``False``}</span>
<span class="sd">        strictly  related to the way  the array ``t`` is passed (see notes ).</span>

<span class="sd">        .. note::</span>

<span class="sd">            - True : ``t`` is a list of array,</span>
<span class="sd">                    ``shape(t)= [nblocks,bandsize]``, to have a Toeplitz band diagonal operator,</span>
<span class="sd">                    :math:`bandsize != blocksize`</span>
<span class="sd">            - False : ``t`` is an array, ``shape(t)=[nblocks]``.</span>
<span class="sd">                    each block is identified by a scalar value in the diagonal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BlockLO.build_blocks"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO.build_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">build_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build each block of the operator either with or</span>
<span class="sd">        without off diagonal terms.</span>
<span class="sd">        Each block is initialized as a Toeplitz (either **band** or **diagonal**)</span>
<span class="sd">        linear operator.</span>

<span class="sd">        .. see also::</span>

<span class="sd">        ``self.diag``: {numpy array}</span>
<span class="sd">            the array resuming the :math:`diag(N^{-1})`.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmplist</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isoffdiag</span><span class="p">:</span>
            <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">ToeplitzLO</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isoffdiag</span><span class="p">:</span>
            <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">DiagonalOperator</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmplist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BlockLO.build_unbalanced_blocks"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO.build_unbalanced_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">build_unbalanced_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the  list of Diagonal blocks of :class:`blk.BlockDiagonalLinearOperator`</span>
<span class="sd">        by assuming that the blocks have different size. Of course it is required that:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \sum _{i=1} ^{nblocks} size(block_i) = N_t</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">tmplist</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">size</span><span class="p">,</span><span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="p">):</span>
            <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">DiagonalOperator</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmplist</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">blocksize</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">offdiag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isoffdiag</span> <span class="o">=</span> <span class="n">offdiag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksize</span><span class="o">=</span><span class="n">blocksize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covnoise</span><span class="o">=</span><span class="n">t</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">blocksize</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_unbalanced_blocks</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_blocks</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BlockLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="BlockLO.isoffdiag"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockLO.isoffdiag">[docs]</a>    <span class="k">def</span> <span class="nf">isoffdiag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property saying whether or not the operator has</span>
<span class="sd">        off-diagonal terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isoffdiag</span>

</div></div>
<div class="viewcode-block" id="BlockDiagonalLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalLO">[docs]</a><span class="k">class</span> <span class="nc">BlockDiagonalLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicit implementation of :math:`A \, diag(N^{-1}) A^T`, in order to save time</span>
<span class="sd">    in the application of the two matrices onto a vector (in this way the leading dimension  will be :math:`n_{pix}`</span>
<span class="sd">    instead of  :math:`n_t`).</span>

<span class="sd">    .. note::</span>
<span class="sd">        it is initialized as the  :class:`BlockDiagonalPreconditionerLO` since it involves</span>
<span class="sd">        computation with  the same matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CES</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">pol</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="n">pol</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">=</span><span class="n">pol</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BlockDiagonalLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>\
                                                <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">sin2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">sincos</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">cos2</span>
            <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">counts</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">cosine</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">sine</span>

<div class="viewcode-block" id="BlockDiagonalLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplication of  :math:`A \, diag(N^{-1}) A^T` on to a vector math:`x`</span>
<span class="sd">        ( :math:`n_{pix}` array).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mf">0.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">hits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">,</span>\
                                                <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">):</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">=</span> <span class="n">hits</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>  <span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>  <span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span>  <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">):</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="n">c2</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>  <span class="n">cs</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">y</span>

</div></div>
<div class="viewcode-block" id="BlockDiagonalPreconditionerLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalPreconditionerLO">[docs]</a><span class="k">class</span> <span class="nc">BlockDiagonalPreconditionerLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standard preconditioner defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        M_{BD}=( A \, diag(N^{-1}) A^T)^{-1}</span>

<span class="sd">    where :math:`A` is the *pointing matrix* (see  :class:`SparseLO`).</span>
<span class="sd">    Such inverse operator  could be easily computed given the structure of the</span>
<span class="sd">    matrix :math:`A`. It could be  sparse in the case of Intensity only analysis (`pol=1`),</span>
<span class="sd">    block-sparse if polarization is included (`pol=3,2`).</span>


<span class="sd">    **Parameters**</span>

<span class="sd">    - ``n``:{int}</span>
<span class="sd">        the size of the problem, ``npix``;</span>
<span class="sd">    - ``CES``:{:class:`ProcessTimeSamples`}</span>
<span class="sd">        the linear operator related to the data sample processing. Its members (`counts`, `masks`,</span>
<span class="sd">        `sine`, `cosine`, etc... ) are  needed to explicitly compute the inverse of the</span>
<span class="sd">        :math:`n_{pix}` blocks of :math:`M_{BD}`.</span>
<span class="sd">    - ``pol``:{int}</span>
<span class="sd">        the size of each block of the matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BlockDiagonalPreconditionerLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.BlockDiagonalPreconditionerLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Action of :math:`y=( A \, diag(N^{-1}) A^T)^{-1} x`,</span>
<span class="sd">        where :math:`x` is   an :math:`n_{pix}` array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mf">0.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">nan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="n">nan</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">nan</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">nan</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">determ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">)</span>\
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span>\
                <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span>
            <span class="n">nan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">determ</span><span class="p">),</span><span class="mf">1e-5</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">det</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">hits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="p">,</span><span class="n">determ</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">,</span>\
                                <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span>  <span class="n">nan</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">pix</span><span class="p">]:</span> <span class="k">continue</span>

                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span>  <span class="o">=</span><span class="p">((</span><span class="n">c2</span><span class="o">*</span><span class="n">s2</span><span class="o">-</span><span class="n">cs</span><span class="o">*</span><span class="n">cs</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">cs</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span><span class="p">(</span> <span class="n">c</span><span class="o">*</span><span class="n">cs</span><span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">s</span><span class="o">*</span><span class="n">cs</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span> <span class="p">(</span><span class="n">hits</span><span class="o">*</span><span class="n">s2</span><span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span><span class="p">(</span> <span class="n">s</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">hits</span><span class="o">*</span><span class="n">cs</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">c</span><span class="o">*</span><span class="n">cs</span> <span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="n">hits</span><span class="o">*</span><span class="n">cs</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span><span class="p">(</span><span class="n">hits</span><span class="o">*</span><span class="n">c2</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">pix</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>

            <span class="n">determ</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">)</span>
            <span class="n">nan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">determ</span><span class="p">),</span><span class="mf">1e-5</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pix</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">cs</span><span class="p">,</span><span class="n">det</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="p">,</span><span class="n">determ</span><span class="p">):</span>
                <span class="n">tr</span><span class="o">=</span><span class="n">c2</span><span class="o">+</span><span class="n">s2</span>
                <span class="n">sqrt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tr</span><span class="o">*</span><span class="n">tr</span><span class="o">/</span><span class="mf">4.</span> <span class="o">-</span><span class="n">det</span><span class="p">)</span>
                <span class="n">lambda_max</span><span class="o">=</span><span class="n">tr</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">sqrt</span>
                <span class="n">lambda_min</span><span class="o">=</span><span class="n">tr</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">sqrt</span>
                <span class="n">cond_num</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_max</span><span class="o">/</span><span class="n">lambda_min</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nan</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">pix</span><span class="p">]:</span>  <span class="k">continue</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="p">(</span> <span class="n">s2</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">-</span> <span class="n">cs</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">y</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>  <span class="p">(</span><span class="o">-</span><span class="n">cs</span>  <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pix</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">pix</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
        <span class="k">return</span> <span class="n">y</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">CES</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">pol</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="n">pol</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="o">=</span><span class="n">pol</span>
        <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">elif</span> <span class="n">pol</span><span class="o">&gt;</span><span class="mi">1</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sin2</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">sin2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cos2</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">cos2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sincos</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">sincos</span>
            <span class="k">if</span> <span class="n">pol</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">counts</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cos</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">cosine</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sin</span><span class="o">=</span><span class="n">CES</span><span class="o">.</span><span class="n">sine</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BlockDiagonalPreconditionerLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>\
                                                            <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="InverseLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO">[docs]</a><span class="k">class</span> <span class="nc">InverseLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the inverse operator of a matrix :math:`A`, as a linear operator.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``A`` : {linear operator}</span>
<span class="sd">        the linear operator of the linear system to invert;</span>
<span class="sd">    - ``method`` : {function }</span>
<span class="sd">        the method to compute ``A^-1`` (see below);</span>
<span class="sd">    - ``P`` : {linear operator } (optional)</span>
<span class="sd">        the preconditioner for the computation of the inverse operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InverseLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It returns  :math:`y=A^{-1}x` by solving the linear system :math:`Ay=x`</span>
<span class="sd">        with a certain :mod:`scipy` routine (e.g. :func:`scipy.sparse.linalg.cg`)</span>
<span class="sd">        defined above as ``method``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span><span class="p">,</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">preconditioner</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isconverged</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>
</div>
<div class="viewcode-block" id="InverseLO.isconverged"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.isconverged">[docs]</a>    <span class="k">def</span> <span class="nf">isconverged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It returns a Boolean value  depending on the</span>
<span class="sd">        exit status of the solver.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - ``info`` : {int}</span>
<span class="sd">            output of the solver method (usually :func:`scipy.sparse.cg`).</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__converged</span><span class="o">=</span><span class="n">info</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">preconditioner</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InverseLO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nargout</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                                <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="o">=</span><span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__preconditioner</span><span class="o">=</span><span class="n">preconditioner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__converged</span><span class="o">=</span><span class="bp">None</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="InverseLO.method"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.method">[docs]</a>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method to compute the inverse of A. \</span>
<span class="sd">        It can be any :mod:`scipy.sparse.linalg` solver, namely :func:`scipy.sparse.linalg.cg`,</span>
<span class="sd">        :func:`scipy.sparse.linalg.bicg`, etc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="InverseLO.converged"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.converged">[docs]</a>    <span class="k">def</span> <span class="nf">converged</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        provides convergence information:</span>

<span class="sd">        - 0 : successful exit;</span>
<span class="sd">        - &gt;0 : convergence to tolerance not achieved, number of iterations;</span>
<span class="sd">        - &lt;0 : illegal input or breakdown.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__converged</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="InverseLO.preconditioner"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.InverseLO.preconditioner">[docs]</a>    <span class="k">def</span> <span class="nf">preconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preconditioner for the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__preconditioner</span>

</div></div>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span><span class="n">lu</span><span class="p">,</span><span class="n">eigh</span>

<div class="viewcode-block" id="CoarseLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO">[docs]</a><span class="k">class</span> <span class="nc">CoarseLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains all the operation involving the coarse operator :math:`E`.</span>
<span class="sd">    In this implementation :math:`E` is always applied to a vector wiht</span>
<span class="sd">    its inverse : :math:`E^{-1}`.</span>
<span class="sd">    When initialized it performs either an LU or an eigenvalue  decomposition</span>
<span class="sd">    to accelerate the performances of the inversion.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``Z`` : {np.matrix}</span>
<span class="sd">            deflation matrix;</span>
<span class="sd">    - ``A`` : {SparseLO}</span>
<span class="sd">            to  compute vectors :math:`AZ_i`;</span>
<span class="sd">    - ``r`` :  {int}</span>
<span class="sd">            :math:`rank(Z)`, dimension of the deflation subspace;</span>
<span class="sd">    - ``apply``:{str}</span>
<span class="sd">            - ``LU``: performs LU decomposition,</span>
<span class="sd">            - ``eig``: compute the eigenvalues and eigenvectors of ``E``.</span>


<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CoarseLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the multiplication of the inverse coarse operator :math:`x=E^{-1} v`.</span>
<span class="sd">        It exploits the LU decomposition of :math:`E` to solve the system :math:`Ex=v`.</span>
<span class="sd">        It first solves :math:`y=L^{-1} v` and then :math:`x=U^{-1}y`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">lower</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">overwrite_b</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">overwrite_b</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="CoarseLO.mult_eig"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO.mult_eig">[docs]</a>    <span class="k">def</span> <span class="nf">mult_eig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix vector multiplication with :math:`E^{-1}` computed via</span>
<span class="sd">        :func:`setting_inverse_w_eigenvalues`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">invE</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="CoarseLO.setting_inverse_w_eigenvalues"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.CoarseLO.setting_inverse_w_eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">setting_inverse_w_eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This routine computes the inverse of ``E`` by a decomposition through an  eigenvalue</span>
<span class="sd">        decomposition. It further checks whether it has some degenerate eigenvalues,</span>
<span class="sd">        i.e. 0 to numerical precision (``1.e-15``), and eventually excludes these eigenvalues</span>
<span class="sd">        from the anaysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">eigenvals</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">eigh</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">lambda_max</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">eigenvals</span><span class="p">)</span>
        <span class="n">diags</span><span class="o">=</span><span class="n">eigenvals</span><span class="o">*</span><span class="mf">0.</span>
        <span class="n">threshold_to_degen</span><span class="o">=</span><span class="mf">1.e-6</span>
        <span class="n">nondegenerate</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">eigenvals</span><span class="o">/</span><span class="n">lambda_max</span><span class="p">)</span><span class="o">&gt;</span><span class="n">threshold_to_degen</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">degenerate</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">eigenvals</span><span class="o">/</span><span class="n">lambda_max</span><span class="p">)</span><span class="o">&lt;</span><span class="n">threshold_to_degen</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span><span class="o">=</span><span class="n">bash_colors</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">degenerate</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s">&quot;===&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s"> DISCARDING </span><span class="si">%d</span><span class="s"> OUT OF </span><span class="si">%d</span><span class="s"> EIGENVALUES</span><span class="se">\t</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degenerate</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">eigenvals</span><span class="p">)))</span>
            <span class="k">print</span> <span class="n">eigenvals</span><span class="p">[</span><span class="n">degenerate</span><span class="p">]</span>
            <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s">&quot;===&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s">&quot;===&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s"> Matrix E is not singular, all its eigenvalues have been taken into account</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s">&quot;===&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nondegenerate</span><span class="p">:</span>
                <span class="n">diags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">eigenvals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">D</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diags</span><span class="p">)</span>

        <span class="n">tmp</span><span class="o">=</span><span class="n">dgemm</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invE</span><span class="o">=</span><span class="n">dgemm</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">tmp</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c">#W.dot(D.dot(W.T))</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Az</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="nb">apply</span><span class="o">=</span><span class="s">&#39;LU&#39;</span><span class="p">):</span>
        <span class="n">M</span><span class="o">=</span><span class="n">dgemm</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">Az</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">apply</span><span class="o">==</span><span class="s">&#39;eig&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setting_inverse_w_eigenvalues</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">CoarseLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult_eig</span><span class="p">,</span>
                                            <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">apply</span> <span class="o">==</span><span class="s">&#39;LU&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">=</span><span class="n">lu</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">permute_l</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">overwrite_a</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">check_finite</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">CoarseLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">nargout</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span>
                                            <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DeflationLO"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.DeflationLO">[docs]</a><span class="k">class</span> <span class="nc">DeflationLO</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class builds the Deflation operator (and its transpose)</span>
<span class="sd">    from the columns of the matrix ``Z``.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - ``z`` : {np.matrix}</span>
<span class="sd">            the deflation matrix. Its columns are read as arrays in a list ``self.z``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DeflationLO.mult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.DeflationLO.mult">[docs]</a>    <span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the matrix vector multiplication   :math:`Z x`</span>
<span class="sd">        with  :math:`dim(x) = rank(Z)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">y</span><span class="o">+=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   <span class="c">#.astype(x.dtype)</span>
        <span class="k">return</span> <span class="n">y</span></div>
<div class="viewcode-block" id="DeflationLO.rmult"><a class="viewcode-back" href="../../interfaces.html#interfaces.linearoperators.DeflationLO.rmult">[docs]</a>    <span class="k">def</span> <span class="nf">rmult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the product onto a ``N_pix`` vector with :math:`Z^T`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">scalprod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span> <span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="o">=</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[:,</span><span class="n">j</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DeflationLO</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nargin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nargout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span>
                                                <span class="n">matvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                <span class="n">rmatvec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rmult</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Modules</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2016, Giuseppe Puglisi.
      Last updated on Jun 28, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>